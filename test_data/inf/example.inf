use inference::std;
use inference::std::collections::{ Array, Set };
use inference::std::types::Address;
use { sorting_function } from "./sort.rs";

enum Arch {
  Wasm,
  X86,
  Arm
}

struct Pizza {
	toppings : [PizzaTopping; 5];
}

struct Pizza1 {
	toppings : [PizzaTopping; 5];
	numSlices : i32;
	thinCrust : bool;
}

struct Identity {
  field : T;

  fn getField() -> T {
    return ctx.field;
  }

}

///this is the sort function Inference spec
context sort_function_context {

  external fn sorting_function (Address, Address) -> Address;
  type sf = typeof(sorting_function);

  fn constructor() -> some_context {
    ctx.type = ContextType::Program;
    ctx.arh = Arch::WASM;
    ctx.max_curr_mem = 2 ** 16;
    ctx.mem = Array<u32>::new(ctx.max_curr_mem);
  }

  fn valid_Address(a: Address) -> Address {
    assert a < ctx.max_curr_mem && !(a % 4);
    return a;
  }

  fn count_values(a: Address, b: Address, val : i32) -> u32 {
    let res : u32 = 0;
    for (let i : Address = a; i <= b; i.next()) {
      if (ctx.mem.at(i) == val) {
        res = res + 1;
      }
    }
    return res;
  }

  total fn preserving_count(func : sf) {
    let undef a: Address;
    let undef b: Address;

    filter {
      a = valid_Address(i32::all());
      b = valid_Address(i32::all());
      assert a <= b;
    }

    let val : i32 = i32::all();
    
    let before : u32 = count_values(a, b, val);
    func(a, b);
    let after : u32 = count_values(a, b, val);
    
    assert before == after;
  }

  total fn procuring_sorted(func: sf) {
    let undef a: Address;
    let undef b: Address;
    let undef a0: Address;
    let undef b0: Address;

    filter {
      a = valid_Address(i32::all());
      b = valid_Address(i32::all());
      assert a <= b;
    }

    func(a, b);

    filter {
      a0 = valid_Address(i32::all());
      b0 = valid_Address(i32::all());

      assert a <= a0;
      assert a0 < b0;
      assert b0 <= b;
    }

    assert ctx.mem.at(a0) <= ctx.mem.at(b0);
  }

  total fn no_side_effects(func : sf) {
    let undef a: Address;
    let undef b: Address;

    let undef c0: Address;

    filter {
      a = valid_Address(i32::all());
      b = valid_Address(i32::all());
      c = valid_Address(i32::all());
      assert a <= b;
      assert c < a || c > b;
    }

    let before : i32 = ctx.mem.at(c);
    func(a, b);
    let after : i32 = ctx.mem.at(c);

    assert before == after;
  }

  fn proof() -> () {
    verify preserving_count(sort);
    verify procuring_sorted(sort);
  }

  const arr : [i32;3] = [1,2,3];

  fn get_first(xs: [i32; 3]) -> i32 {
    return xs[0];
  }

  fn concat_ints(xss : [[i64]]) -> [i64] {

  }

}
