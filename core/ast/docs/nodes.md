# AST Node Types Reference

Comprehensive reference for all AST node types in the Inference compiler.

## Table of Contents

1. [Overview](#overview)
2. [Node Hierarchy](#node-hierarchy)
3. [Common Node Properties](#common-node-properties)
4. [Top-Level Nodes](#top-level-nodes)
5. [Directives](#directives)
6. [Definitions](#definitions)
7. [Statements](#statements)
8. [Expressions](#expressions)
9. [Literals](#literals)
10. [Types](#types)
11. [Arguments](#arguments)
12. [Miscellaneous Nodes](#miscellaneous-nodes)

## Overview

All AST nodes in the Inference compiler are defined using custom macros that provide consistent interfaces. Every node has:

- A unique `id: u32`
- A `location: Location` with source position information
- Type-specific fields

Nodes are stored in the Arena and referenced by ID, not by pointer.

## Node Hierarchy

The AST uses a discriminated union structure with the `AstNode` enum as the root:

```
AstNode
├── Ast
│   └── SourceFile
├── Directive
│   └── Use
├── Definition
│   ├── Spec
│   ├── Struct
│   ├── Enum
│   ├── Constant
│   ├── Function
│   ├── ExternalFunction
│   ├── Type
│   └── Module
├── BlockType
│   ├── Block
│   ├── Assume
│   ├── Forall
│   ├── Exists
│   └── Unique
├── Statement
│   ├── Block
│   ├── Expression
│   ├── Assign
│   ├── Return
│   ├── Loop
│   ├── Break
│   ├── If
│   ├── VariableDefinition
│   ├── TypeDefinition
│   ├── Assert
│   └── ConstantDefinition
├── Expression
│   ├── ArrayIndexAccess
│   ├── Binary
│   ├── MemberAccess
│   ├── TypeMemberAccess
│   ├── FunctionCall
│   ├── Struct
│   ├── PrefixUnary
│   ├── Parenthesized
│   ├── Literal
│   ├── Identifier
│   ├── Type
│   └── Uzumaki
├── Literal
│   ├── Array
│   ├── Bool
│   ├── String
│   ├── Number
│   └── Unit
├── Type
│   ├── Array
│   ├── Simple
│   ├── Generic
│   ├── Function
│   ├── QualifiedName
│   ├── Qualified
│   └── Custom
├── ArgumentType
│   ├── SelfReference
│   ├── IgnoreArgument
│   ├── Argument
│   └── Type
└── Misc
    └── StructField
```

## Common Node Properties

All nodes generated by the `ast_node!` macro have:

```rust
pub struct SomeNode {
    pub id: u32,                    // Unique identifier
    pub location: Location,         // Source position
    // ... type-specific fields
}
```

### Accessing Common Properties

```rust
// For any AstNode
let node = arena.find_node(node_id)?;
let id = node.id();              // Get node ID
let loc = node.location();       // Get location (Copy)
let line = node.start_line();    // Convenience method
```

## Top-Level Nodes

### SourceFile

Root node representing a parsed source file.

```rust
pub struct SourceFile {
    pub id: u32,
    pub location: Location,
    pub source: String,              // Complete source text
    pub directives: Vec<Directive>,  // Use statements
    pub definitions: Vec<Definition>,// Top-level definitions
}
```

**Example source:**
```inference
use std::io;

fn main() -> i32 {
    return 0;
}
```

**Fields:**
- `source`: The entire file contents as a string
- `directives`: Import/use directives
- `definitions`: Functions, types, structs, etc.

## Directives

### UseDirective

Import statement for bringing external symbols into scope.

```rust
pub struct UseDirective {
    pub id: u32,
    pub location: Location,
    pub imported_types: Option<Vec<Rc<Identifier>>>,
    pub segments: Option<Vec<Rc<Identifier>>>,
    pub from: Option<String>,
}
```

**Example source:**
```inference
use std::{io, fs};
use core::option::Option;
```

**Fields:**
- `imported_types`: Specific types to import (e.g., `{io, fs}`)
- `segments`: Module path segments (e.g., `std`, `core`)
- `from`: Optional source path

## Definitions

### SpecDefinition

Specification or interface definition.

```rust
pub struct SpecDefinition {
    pub id: u32,
    pub location: Location,
    pub visibility: Visibility,
    pub name: Rc<Identifier>,
    pub definitions: Vec<Definition>,
}
```

**Example source:**
```inference
pub spec Comparable {
    fn compare(self, other: Self) -> i32;
}
```

### StructDefinition

Structure definition with fields and methods.

```rust
pub struct StructDefinition {
    pub id: u32,
    pub location: Location,
    pub visibility: Visibility,
    pub name: Rc<Identifier>,
    pub fields: Vec<Rc<StructField>>,
    pub methods: Vec<Rc<FunctionDefinition>>,
}
```

**Example source:**
```inference
pub struct Point {
    x: i32;
    y: i32;
}
```

**Fields:**
- `visibility`: `Public` or `Private`
- `name`: Struct identifier
- `fields`: List of struct fields
- `methods`: Associated functions

### EnumDefinition

Enumeration type definition.

```rust
pub struct EnumDefinition {
    pub id: u32,
    pub location: Location,
    pub visibility: Visibility,
    pub name: Rc<Identifier>,
    pub variants: Vec<Rc<Identifier>>,
}
```

**Example source:**
```inference
pub enum Color {
    Red;
    Green;
    Blue;
}
```

### FunctionDefinition

Function definition with signature and body.

```rust
pub struct FunctionDefinition {
    pub id: u32,
    pub location: Location,
    pub visibility: Visibility,
    pub name: Rc<Identifier>,
    pub type_parameters: Option<Vec<Rc<Identifier>>>,
    pub arguments: Option<Vec<ArgumentType>>,
    pub returns: Option<Type>,
    pub body: BlockType,
}
```

**Example source:**
```inference
pub fn add(a: i32, b: i32) -> i32 {
    return a + b;
}
```

**Fields:**
- `type_parameters`: Generic type parameters (e.g., `<T, U>`)
- `arguments`: Function parameters
- `returns`: Return type (None for unit return)
- `body`: Function body (Block, Forall, Exists, etc.)

### ExternalFunctionDefinition

External function declaration (no body).

```rust
pub struct ExternalFunctionDefinition {
    pub id: u32,
    pub location: Location,
    pub visibility: Visibility,
    pub name: Rc<Identifier>,
    pub arguments: Option<Vec<ArgumentType>>,
    pub returns: Option<Type>,
}
```

**Example source:**
```inference
extern fn malloc(size: i32) -> i32;
```

### TypeDefinition

Type alias definition.

```rust
pub struct TypeDefinition {
    pub id: u32,
    pub location: Location,
    pub visibility: Visibility,
    pub name: Rc<Identifier>,
    pub ty: Type,
}
```

**Example source:**
```inference
type Age = i32;
type Callback = fn(i32) -> i32;
```

### ModuleDefinition

Module definition for namespacing.

```rust
pub struct ModuleDefinition {
    pub id: u32,
    pub location: Location,
    pub visibility: Visibility,
    pub name: Rc<Identifier>,
    pub body: Option<Vec<Definition>>,
}
```

**Example source:**
```inference
pub mod math {
    fn add(a: i32, b: i32) -> i32 { return a + b; }
}
```

### ConstantDefinition

Constant value definition.

```rust
pub struct ConstantDefinition {
    pub id: u32,
    pub location: Location,
    pub visibility: Visibility,
    pub name: Rc<Identifier>,
    pub ty: Type,
    pub value: Literal,
}
```

**Example source:**
```inference
const PI: f64 = 3.14159;
const MAX_SIZE: i32 = 100;
```

## Statements

### Block

Sequence of statements within braces.

```rust
pub struct Block {
    pub id: u32,
    pub location: Location,
    pub statements: Vec<Statement>,
}
```

**Example source:**
```inference
{
    let x: i32 = 10;
    let y: i32 = 20;
    return x + y;
}
```

### Non-Deterministic Blocks

Special block types for non-deterministic execution:

```rust
pub enum BlockType {
    Block(Rc<Block>),       // Standard block
    Assume(Rc<Block>),      // Assumption block
    Forall(Rc<Block>),      // Universal quantification
    Exists(Rc<Block>),      // Existential quantification
    Unique(Rc<Block>),      // Unique existence
}
```

**Example source:**
```inference
fn test() {
    forall {
        let x: i32 = uzumaki;
        assert(x >= 0);
    }
}
```

### ReturnStatement

Return statement with optional expression.

```rust
pub struct ReturnStatement {
    pub id: u32,
    pub location: Location,
    pub expression: RefCell<Expression>,
}
```

**Example source:**
```inference
return 42;
return x + y;
```

### IfStatement

Conditional branching statement.

```rust
pub struct IfStatement {
    pub id: u32,
    pub location: Location,
    pub condition: RefCell<Expression>,
    pub if_arm: BlockType,
    pub else_arm: Option<BlockType>,
}
```

**Example source:**
```inference
if (x > 0) {
    return x;
} else {
    return 0;
}
```

### LoopStatement

Loop with optional condition (while loop or infinite loop).

```rust
pub struct LoopStatement {
    pub id: u32,
    pub location: Location,
    pub condition: RefCell<Option<Expression>>,
    pub body: BlockType,
}
```

**Example source:**
```inference
// Infinite loop
loop {
    break;
}

// While loop
loop (x < 10) {
    x = x + 1;
}
```

### BreakStatement

Loop exit statement.

```rust
pub struct BreakStatement {
    pub id: u32,
    pub location: Location,
}
```

**Example source:**
```inference
loop {
    if (done) {
        break;
    }
}
```

### VariableDefinitionStatement

Variable declaration with optional initialization.

```rust
pub struct VariableDefinitionStatement {
    pub id: u32,
    pub location: Location,
    pub name: Rc<Identifier>,
    pub ty: Type,
    pub value: Option<RefCell<Expression>>,
    pub is_uzumaki: bool,
}
```

**Example source:**
```inference
let x: i32 = 42;
let y: i32;
let z: i32 = uzumaki;  // Non-deterministic
```

**Fields:**
- `is_uzumaki`: True if initialized with non-deterministic value

### AssignStatement

Assignment to existing variable or expression.

```rust
pub struct AssignStatement {
    pub id: u32,
    pub location: Location,
    pub left: RefCell<Expression>,
    pub right: RefCell<Expression>,
}
```

**Example source:**
```inference
x = 10;
arr[0] = 42;
point.x = 5;
```

### AssertStatement

Runtime assertion for verification.

```rust
pub struct AssertStatement {
    pub id: u32,
    pub location: Location,
    pub expression: RefCell<Expression>,
}
```

**Example source:**
```inference
assert(x > 0);
assert(len < MAX_SIZE);
```

## Expressions

### BinaryExpression

Binary operation between two expressions.

```rust
pub struct BinaryExpression {
    pub id: u32,
    pub location: Location,
    pub left: RefCell<Expression>,
    pub operator: OperatorKind,
    pub right: RefCell<Expression>,
}
```

**Operators:**
```rust
pub enum OperatorKind {
    Pow,      // **
    Add,      // +
    Sub,      // -
    Mul,      // *
    Div,      // /  (Added in issue #86)
    Mod,      // %
    And,      // &&
    Or,       // ||
    Eq,       // ==
    Ne,       // !=
    Lt,       // <
    Le,       // <=
    Gt,       // >
    Ge,       // >=
    BitAnd,   // &
    BitOr,    // |
    BitXor,   // ^
    BitNot,   // ~
    Shl,      // <<
    Shr,      // >>
}
```

**Example source:**
```inference
x + y
a * b + c
a / b              // Division operator (issue #86)
flag && (count > 0)
x % 2 == 0         // Modulo
```

### PrefixUnaryExpression

Unary operation on an expression.

```rust
pub struct PrefixUnaryExpression {
    pub id: u32,
    pub location: Location,
    pub expression: RefCell<Expression>,
    pub operator: UnaryOperatorKind,
}

pub enum UnaryOperatorKind {
    Not,     // !  - Logical negation
    Neg,     // -  - Numeric negation (Added in issue #86)
    BitNot,  // ~  - Bitwise NOT (Added in issue #86)
}
```

**Example source:**
```inference
!flag              // Logical NOT
!(x > 0)
-x                 // Numeric negation (issue #86)
-42
~mask              // Bitwise NOT (issue #86)
~0xFF
```

### FunctionCallExpression

Function invocation with arguments.

```rust
pub struct FunctionCallExpression {
    pub id: u32,
    pub location: Location,
    pub function: Expression,
    pub type_parameters: Option<Vec<Rc<Identifier>>>,
    pub arguments: Option<Vec<(Option<Rc<Identifier>>, RefCell<Expression>)>>,
}
```

**Example source:**
```inference
add(1, 2)
max::<i32>(a, b)
println(msg: "Hello")  // Named argument
```

### MemberAccessExpression

Accessing a struct field or method.

```rust
pub struct MemberAccessExpression {
    pub id: u32,
    pub location: Location,
    pub expression: RefCell<Expression>,
    pub name: Rc<Identifier>,
}
```

**Example source:**
```inference
point.x
person.age
obj.method()
```

### ArrayIndexAccessExpression

Accessing array element by index.

```rust
pub struct ArrayIndexAccessExpression {
    pub id: u32,
    pub location: Location,
    pub array: RefCell<Expression>,
    pub index: RefCell<Expression>,
}
```

**Example source:**
```inference
arr[0]
matrix[i][j]
```

### StructExpression

Struct literal construction.

```rust
pub struct StructExpression {
    pub id: u32,
    pub location: Location,
    pub name: Rc<Identifier>,
    pub fields: Option<Vec<(Rc<Identifier>, RefCell<Expression>)>>,
}
```

**Example source:**
```inference
Point { x: 10; y: 20; }
Color { r: 255; g: 0; b: 0; }
```

### ParenthesizedExpression

Expression wrapped in parentheses.

```rust
pub struct ParenthesizedExpression {
    pub id: u32,
    pub location: Location,
    pub expression: RefCell<Expression>,
}
```

**Example source:**
```inference
(x + y)
(a * b) + c
```

### UzumakiExpression

Non-deterministic value expression.

```rust
pub struct UzumakiExpression {
    pub id: u32,
    pub location: Location,
}
```

**Example source:**
```inference
let x: i32 = uzumaki;
```

## Literals

### NumberLiteral

Numeric literal (integer or float).

```rust
pub struct NumberLiteral {
    pub id: u32,
    pub location: Location,
    pub value: String,  // Stored as string for precision
}
```

**Example source:**
```inference
42
3.14159
0xFF
```

### StringLiteral

String literal.

```rust
pub struct StringLiteral {
    pub id: u32,
    pub location: Location,
    pub value: String,
}
```

**Example source:**
```inference
"Hello, world!"
"multi\nline\nstring"
```

### BoolLiteral

Boolean literal.

```rust
pub struct BoolLiteral {
    pub id: u32,
    pub location: Location,
    pub value: bool,
}
```

**Example source:**
```inference
true
false
```

### ArrayLiteral

Array literal with elements.

```rust
pub struct ArrayLiteral {
    pub id: u32,
    pub location: Location,
    pub elements: Option<Vec<RefCell<Expression>>>,
}
```

**Example source:**
```inference
[1, 2, 3]
[x, y, z]
[]  // Empty array
```

### UnitLiteral

Unit type literal (void).

```rust
pub struct UnitLiteral {
    pub id: u32,
    pub location: Location,
}
```

**Example source:**
```inference
()
```

## Types

### SimpleType

Built-in primitive type.

```rust
pub struct SimpleType {
    pub id: u32,
    pub location: Location,
    pub name: String,
}
```

**Example source:**
```inference
i32
f64
bool
str
```

### TypeArray

Array type with element type and size.

```rust
pub struct TypeArray {
    pub id: u32,
    pub location: Location,
    pub element_type: Type,
    pub size: Expression,
}
```

**Example source:**
```inference
[i32; 10]
[bool; N]
```

### GenericType

Generic type with type parameters.

```rust
pub struct GenericType {
    pub id: u32,
    pub location: Location,
    pub base: Rc<Identifier>,
    pub parameters: Vec<Rc<Identifier>>,
}
```

**Example source:**
```inference
Vec<i32>
HashMap<String, i32>
```

### FunctionType

Function type signature.

```rust
pub struct FunctionType {
    pub id: u32,
    pub location: Location,
    pub parameters: Option<Vec<Type>>,
    pub returns: Option<Type>,
}
```

**Example source:**
```inference
fn(i32, i32) -> i32
fn() -> bool
```

### QualifiedName

Module-qualified type name.

```rust
pub struct QualifiedName {
    pub id: u32,
    pub location: Location,
    pub qualifier: Rc<Identifier>,
    pub name: Rc<Identifier>,
}
```

**Example source:**
```inference
std::io::File
core::option::Option
```

## Arguments

### Argument

Named function parameter with type.

```rust
pub struct Argument {
    pub id: u32,
    pub location: Location,
    pub name: Rc<Identifier>,
    pub is_mut: bool,
    pub ty: Type,
}
```

**Example source:**
```inference
fn test(x: i32, mut y: i32) { ... }
```

### SelfReference

Self parameter for methods.

```rust
pub struct SelfReference {
    pub id: u32,
    pub location: Location,
    pub is_mut: bool,
}
```

**Example source:**
```inference
fn method(self) { ... }
fn mut_method(mut self) { ... }
```

### IgnoreArgument

Unnamed parameter (only type specified).

```rust
pub struct IgnoreArgument {
    pub id: u32,
    pub location: Location,
    pub ty: Type,
}
```

**Example source:**
```inference
fn callback(_: i32) { ... }
```

## Miscellaneous Nodes

### Identifier

Named identifier.

```rust
pub struct Identifier {
    pub id: u32,
    pub location: Location,
    pub name: String,
}
```

**Example source:**
```inference
x
variable_name
function_name
```

### StructField

Struct field definition.

```rust
pub struct StructField {
    pub id: u32,
    pub location: Location,
    pub name: Rc<Identifier>,
    pub type_: Type,
}
```

**Example source:**
```inference
struct Point {
    x: i32;  // StructField
    y: i32;  // StructField
}
```

### Visibility

Visibility modifier for definitions.

```rust
pub enum Visibility {
    Private,  // Default (no modifier)
    Public,   // pub keyword
}
```

**Supported Definitions (Issue #86)**:
- `FunctionDefinition` - Functions can be marked `pub fn`
- `StructDefinition` - Structs can be marked `pub struct`
- `EnumDefinition` - Enums can be marked `pub enum`
- `ConstantDefinition` - Constants can be marked `pub const`
- `TypeDefinition` - Type aliases can be marked `pub type`
- `ModuleDefinition` - Modules can be marked `pub mod`

**Example source:**
```inference
pub fn public_function() -> i32 { 42 }
fn private_function() -> i32 { 0 }

pub struct PublicStruct { x: i32; }
struct PrivateStruct { y: i32; }

pub enum PublicEnum { A; B; }
enum PrivateEnum { C; D; }

pub const PUBLIC_CONST: i32 = 100;
const PRIVATE_CONST: i32 = 200;

pub type PublicAlias = i32;
type PrivateAlias = i32;
```

## Node Usage Patterns

### Pattern Matching

```rust
match node {
    AstNode::Definition(Definition::Function(func)) => {
        println!("Function: {}", func.name.name);
    }
    AstNode::Statement(Statement::Return(ret)) => {
        println!("Return statement");
    }
    _ => {}
}
```

### Filtering by Type

```rust
// Find all binary expressions
let binary_exprs = arena.filter_nodes(|node| {
    matches!(node, AstNode::Expression(Expression::Binary(_)))
});
```

### Extracting Data

```rust
// Get function names
let function_names: Vec<String> = arena
    .functions()
    .iter()
    .map(|f| f.name.name.clone())
    .collect();
```

## RefCell Usage

Some node fields use `RefCell` for interior mutability during type checking:

```rust
pub struct ReturnStatement {
    pub expression: RefCell<Expression>,  // Can be mutated
}

// Usage
let ret_stmt = ...;
let expr = ret_stmt.expression.borrow();
*ret_stmt.expression.borrow_mut() = new_expr;
```

**When RefCell is used:**
- Expression fields in statements (return, assign, if)
- Mutable fields during semantic analysis
- Fields that may be transformed during type checking

## Node Construction

Nodes are typically created by `AstBuilder` during parsing:

```rust
let mut builder = AstBuilder::new(source);
let arena = builder.build();
```

For testing, you can manually construct nodes:

```rust
let id = Identifier {
    id: 1,
    location: Location::default(),
    name: "test".to_string(),
};
```

## Related Documentation

- [Arena API Guide](arena-api.md) - How to query and traverse nodes
- [Architecture Guide](architecture.md) - Overall system design
- [Location Optimization](location.md) - Source position tracking

## Grammar Reference

For the complete Inference language grammar, see:
- [Inference Language Spec](https://github.com/Inferara/inference-language-spec)
- `tree-sitter-inference` grammar definition
